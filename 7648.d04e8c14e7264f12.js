"use strict";(self.webpackChunkPaperize=self.webpackChunkPaperize||[]).push([[7648],{7648:(_o,At,zt)=>{zt.r(At),zt.d(At,{ByteLengthQueuingStrategy:()=>kt,CountQueuingStrategy:()=>Ot,ReadableByteStreamController:()=>Pe,ReadableStream:()=>ne,ReadableStreamBYOBReader:()=>Ce,ReadableStreamBYOBRequest:()=>Te,ReadableStreamDefaultController:()=>he,ReadableStreamDefaultReader:()=>we,TransformStream:()=>Wt,TransformStreamDefaultController:()=>Ue,WritableStream:()=>je,WritableStreamDefaultController:()=>de,WritableStreamDefaultWriter:()=>Be}),typeof window<"u"||typeof global<"u"&&global;const b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function Je(){}const Bt=typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:void 0;function E(e){return"object"==typeof e&&null!==e||"function"==typeof e}const Ft=Je,Ke=Promise,Qr=Promise.prototype.then,xr=Promise.resolve.bind(Ke),Yr=Promise.reject.bind(Ke);function q(e){return new Ke(e)}function w(e){return xr(e)}function d(e){return Yr(e)}function z(e,t,r){return Qr.call(e,t,r)}function k(e,t,r){z(z(e,t,r),void 0,Ft)}function Ze(e,t){k(e,t)}function It(e,t){k(e,void 0,t)}function x(e,t,r){return z(e,t,r)}function ae(e){z(e,void 0,Ft)}const Lt=(()=>{const e=Bt&&Bt.queueMicrotask;if("function"==typeof e)return e;const t=w(void 0);return r=>z(t,r)})();function me(e,t,r){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function Y(e,t,r){try{return w(me(e,t,r))}catch(o){return d(o)}}class j{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(t){const r=this._back;let o=r;16383===r._elements.length&&(o={_elements:[],_next:void 0}),r._elements.push(t),o!==r&&(this._back=o,r._next=o),++this._size}shift(){const t=this._front;let r=t;const o=this._cursor;let n=o+1;const i=t._elements,s=i[o];return 16384===n&&(r=t._next,n=0),--this._size,this._cursor=n,t!==r&&(this._front=r),i[o]=void 0,s}forEach(t){let r=this._cursor,o=this._front,n=o._elements;for(;!(r===n.length&&void 0===o._next||r===n.length&&(o=o._next,n=o._elements,r=0,0===n.length));)t(n[r]),++r}peek(){return this._front._elements[this._cursor]}}function Mt(e,t){var r;e._ownerReadableStream=t,t._reader=e,"readable"===t._state?tt(e):"closed"===t._state?(tt(r=e),Dt(r)):$t(e,t._storedError)}function et(e,t){return J(e._ownerReadableStream,t)}function H(e){"readable"===e._ownerReadableStream._state?rt(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):$t(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function Z(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function tt(e){e._closedPromise=q((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r})}function $t(e,t){tt(e),rt(e,t)}function rt(e,t){void 0!==e._closedPromise_reject&&(ae(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function Dt(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const Nt=b("[[AbortSteps]]"),Qt=b("[[ErrorSteps]]"),ot=b("[[CancelSteps]]"),nt=b("[[PullSteps]]"),xt=Number.isFinite||function(e){return"number"==typeof e&&isFinite(e)},Hr=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function B(e,t){if(void 0!==e&&"object"!=typeof(r=e)&&"function"!=typeof r)throw new TypeError(t+" is not an object.");var r}function O(e,t){if("function"!=typeof e)throw new TypeError(t+" is not a function.")}function Yt(e,t){if(("object"!=typeof(r=e)||null===r)&&"function"!=typeof r)throw new TypeError(t+" is not an object.");var r}function F(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function it(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function at(e){return Number(e)}function Ht(e){return 0===e?0:e}function Vt(e,t){const r=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=Ht(o),!xt(o))throw new TypeError(t+" is not a finite number");if(o=Ht(Hr(o)),o<0||o>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return xt(o)&&0!==o?o:0}function st(e,t){if(!M(e))throw new TypeError(t+" is not a ReadableStream.")}function ye(e){return new we(e)}function Ut(e,t){e._reader._readRequests.push(t)}function lt(e,t,r){const o=e._reader._readRequests.shift();r?o._closeSteps():o._chunkSteps(t)}function ge(e){return e._reader._readRequests.length}function Gt(e){const t=e._reader;return void 0!==t&&!!V(t)}class we{constructor(t){if(F(t,1,"ReadableStreamDefaultReader"),st(t,"First parameter"),$(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Mt(this,t),this._readRequests=new j}get closed(){return V(this)?this._closedPromise:d(Se("closed"))}cancel(t){return V(this)?void 0===this._ownerReadableStream?d(Z("cancel")):et(this,t):d(Se("cancel"))}read(){if(!V(this))return d(Se("read"));if(void 0===this._ownerReadableStream)return d(Z("read from"));let t,r;const o=q((n,i)=>{t=n,r=i});return ve(this,{_chunkSteps:n=>t({value:n,done:!1}),_closeSteps:()=>t({value:void 0,done:!0}),_errorSteps:n=>r(n)}),o}releaseLock(){if(!V(this))throw Se("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");H(this)}}}function V(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function ve(e,t){const r=e._ownerReadableStream;r._disturbed=!0,"closed"===r._state?t._closeSteps():"errored"===r._state?t._errorSteps(r._storedError):r._readableStreamController[nt](t)}function Se(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}let Re;Object.defineProperties(we.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(we.prototype,b.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),"symbol"==typeof b.asyncIterator&&(Re={[b.asyncIterator](){return this}},Object.defineProperty(Re,b.asyncIterator,{enumerable:!1}));class Vr{constructor(t,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=t,this._preventCancel=r}next(){const t=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?x(this._ongoingPromise,t,t):t(),this._ongoingPromise}return(t){const r=()=>this._returnSteps(t);return this._ongoingPromise?x(this._ongoingPromise,r,r):r()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const t=this._reader;if(void 0===t._ownerReadableStream)return d(Z("iterate"));let r,o;const n=q((i,s)=>{r=i,o=s});return ve(t,{_chunkSteps:i=>{this._ongoingPromise=void 0,Lt(()=>r({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,H(t),r({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,H(t),o(i)}}),n}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:!0});this._isFinished=!0;const r=this._reader;if(void 0===r._ownerReadableStream)return d(Z("finish iterating"));if(!this._preventCancel){const o=et(r,t);return H(r),x(o,()=>({value:t,done:!0}))}return H(r),w({value:t,done:!0})}}const Xt={next(){return Jt(this)?this._asyncIteratorImpl.next():d(Kt("next"))},return(e){return Jt(this)?this._asyncIteratorImpl.return(e):d(Kt("return"))}};function Jt(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl")}function Kt(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}void 0!==Re&&Object.setPrototypeOf(Xt,Re);const Zt=Number.isNaN||function(e){return e!=e};function er(e){return!("number"!=typeof(t=e)||Zt(t)||t<0||e===1/0);var t}function ut(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function ct(e,t,r){if(!er(r=Number(r)))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function I(e){e._queue=new j,e._queueTotalSize=0}function dt(e){return e.slice()}class Te{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!ft(this))throw pt("view");return this._view}respond(t){if(!ft(this))throw pt("respond");if(F(t,1,"respond"),t=Vt(t,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");!function(r,o){if(!er(o=Number(o)))throw new RangeError("bytesWritten must be a finite");ar(r,o)}(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!ft(this))throw pt("respondWithNewView");if(F(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw new TypeError("You can only respond with array buffer views");if(0===t.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===t.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");!function(r,o){const n=r._pendingPullIntos.peek();if(n.byteOffset+n.bytesFilled!==o.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(n.byteLength!==o.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");n.buffer=o.buffer,ar(r,o.byteLength)}(this._associatedReadableByteStreamController,t)}}Object.defineProperties(Te.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Te.prototype,b.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class Pe{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!ee(this))throw le("byobRequest");if(null===this._byobRequest&&this._pendingPullIntos.length>0){const t=this._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(Te.prototype);s=r,(n=o)._associatedReadableByteStreamController=this,n._view=s,this._byobRequest=o}var n,s;return this._byobRequest}get desiredSize(){if(!ee(this))throw le("desiredSize");return sr(this)}close(){if(!ee(this))throw le("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const t=this._controlledReadableByteStream._state;if("readable"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);!function(r){const o=r._controlledReadableByteStream;if(!r._closeRequested&&"readable"===o._state){if(r._queueTotalSize>0)return void(r._closeRequested=!0);if(r._pendingPullIntos.length>0&&r._pendingPullIntos.peek().bytesFilled>0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw se(r,n),n}Ee(r),pe(o)}}(this)}enqueue(t){if(!ee(this))throw le("enqueue");if(F(t,1,"enqueue"),!ArrayBuffer.isView(t))throw new TypeError("chunk must be an array buffer view");if(0===t.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===t.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);!function(o,n){const i=o._controlledReadableByteStream;if(o._closeRequested||"readable"!==i._state)return;const a=n.byteOffset,u=n.byteLength,l=n.buffer;Gt(i)?0===ge(i)?qe(o,l,a,u):lt(i,new Uint8Array(l,a,u),!1):mt(i)?(qe(o,l,a,u),ir(o)):qe(o,l,a,u),U(o)}(this,t)}error(t){if(!ee(this))throw le("error");se(this,t)}[ot](t){this._pendingPullIntos.length>0&&(this._pendingPullIntos.peek().bytesFilled=0),I(this);const r=this._cancelAlgorithm(t);return Ee(this),r}[nt](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const n=this._queue.shift();this._queueTotalSize-=n.byteLength,nr(this);const i=new Uint8Array(n.buffer,n.byteOffset,n.byteLength);return void t._chunkSteps(i)}const o=this._autoAllocateChunkSize;if(void 0!==o){let n;try{n=new ArrayBuffer(o)}catch(s){return void t._errorSteps(s)}const i={buffer:n,byteOffset:0,byteLength:o,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i)}Ut(r,t),U(this)}}function ee(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function ft(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function U(e){if(function(t){const r=t._controlledReadableByteStream;return!("readable"!==r._state||t._closeRequested||!t._started||!(Gt(r)&&ge(r)>0||mt(r)&&ur(r)>0||sr(t)>0))}(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,k(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,U(e))},t=>{se(e,t)})}}function ht(e,t){let r=!1;"closed"===e._state&&(r=!0);const o=tr(t);"default"===t.readerType?lt(e,o,r):function(n,i,s){const a=n._reader._readIntoRequests.shift();s?a._closeSteps(i):a._chunkSteps(i)}(e,o,r)}function tr(e){return new e.viewConstructor(e.buffer,e.byteOffset,e.bytesFilled/e.elementSize)}function qe(e,t,r,o){e._queue.push({buffer:t,byteOffset:r,byteLength:o}),e._queueTotalSize+=o}function rr(e,t){const r=t.elementSize,o=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),i=t.bytesFilled+n,s=i-i%r;let a=n,u=!1;s>o&&(a=s-t.bytesFilled,u=!0);const l=e._queue;for(;a>0;){const m=l.peek(),h=Math.min(a,m.byteLength);_=t.byteOffset+t.bytesFilled,c=m.buffer,y=m.byteOffset,g=h,new Uint8Array(t.buffer).set(new Uint8Array(c,y,g),_),m.byteLength===h?l.shift():(m.byteOffset+=h,m.byteLength-=h),e._queueTotalSize-=h,or(e,h,t),a-=h}var _,c,y,g;return u}function or(e,t,r){_t(e),r.bytesFilled+=t}function nr(e){0===e._queueTotalSize&&e._closeRequested?(Ee(e),pe(e._controlledReadableByteStream)):U(e)}function _t(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function ir(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();rr(e,t)&&(bt(e),ht(e._controlledReadableByteStream,t))}}function ar(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(o,n){n.buffer=n.buffer;const i=o._controlledReadableByteStream;if(mt(i))for(;ur(i)>0;)ht(i,bt(o))}(e,r)}else!function(o,n,i){if(i.bytesFilled+n>i.byteLength)throw new RangeError("bytesWritten out of range");if(or(o,n,i),i.bytesFilled<i.elementSize)return;bt(o);const s=i.bytesFilled%i.elementSize;if(s>0){const a=i.byteOffset+i.bytesFilled,u=i.buffer.slice(a-s,a);qe(o,u,0,u.byteLength)}i.buffer=i.buffer,i.bytesFilled-=s,ht(o._controlledReadableByteStream,i),ir(o)}(e,t,r);U(e)}function bt(e){const t=e._pendingPullIntos.shift();return _t(e),t}function Ee(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function se(e,t){const r=e._controlledReadableByteStream;var o;"readable"===r._state&&(_t(o=e),o._pendingPullIntos=new j,I(e),Ee(e),jr(r,t))}function sr(e){const t=e._controlledReadableByteStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function pt(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function le(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function lr(e,t){e._reader._readIntoRequests.push(t)}function ur(e){return e._reader._readIntoRequests.length}function mt(e){const t=e._reader;return void 0!==t&&!!ue(t)}Object.defineProperties(Pe.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Pe.prototype,b.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class Ce{constructor(t){if(F(t,1,"ReadableStreamBYOBReader"),st(t,"First parameter"),$(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!ee(t._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Mt(this,t),this._readIntoRequests=new j}get closed(){return ue(this)?this._closedPromise:d(ke("closed"))}cancel(t){return ue(this)?void 0===this._ownerReadableStream?d(Z("cancel")):et(this,t):d(ke("cancel"))}read(t){if(!ue(this))return d(ke("read"));if(!ArrayBuffer.isView(t))return d(new TypeError("view must be an array buffer view"));if(0===t.byteLength)return d(new TypeError("view must have non-zero byteLength"));if(0===t.buffer.byteLength)return d(new TypeError("view's buffer must have non-zero byteLength"));if(void 0===this._ownerReadableStream)return d(Z("read from"));let r,o;const n=q((i,s)=>{r=i,o=s});return function(i,s,a){const u=i._ownerReadableStream;u._disturbed=!0,"errored"===u._state?a._errorSteps(u._storedError):function(l,f,_){const c=l._controlledReadableByteStream;let y=1;f.constructor!==DataView&&(y=f.constructor.BYTES_PER_ELEMENT);const g=f.constructor,m={buffer:f.buffer,byteOffset:f.byteOffset,byteLength:f.byteLength,bytesFilled:0,elementSize:y,viewConstructor:g,readerType:"byob"};if(l._pendingPullIntos.length>0)return l._pendingPullIntos.push(m),void lr(c,_);if("closed"!==c._state){if(l._queueTotalSize>0){if(rr(l,m)){const h=tr(m);return nr(l),void _._chunkSteps(h)}if(l._closeRequested){const h=new TypeError("Insufficient bytes to fill elements in the given buffer");return se(l,h),void _._errorSteps(h)}}l._pendingPullIntos.push(m),lr(c,_),U(l)}else{const h=new g(m.buffer,m.byteOffset,0);_._closeSteps(h)}}(u._readableStreamController,s,a)}(this,t,{_chunkSteps:i=>r({value:i,done:!1}),_closeSteps:i=>r({value:i,done:!0}),_errorSteps:i=>o(i)}),n}releaseLock(){if(!ue(this))throw ke("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");H(this)}}}function ue(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function ke(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function ce(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(Zt(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function Oe(e){const{size:t}=e;return t||(()=>1)}function We(e,t){B(e,t);const r=e?.highWaterMark,o=e?.size;return{highWaterMark:void 0===r?void 0:at(r),size:void 0===o?void 0:Gr(o,t+" has member 'size' that")}}function Gr(e,t){return O(e,t),r=>at(e(r))}function Xr(e,t,r){return O(e,r),o=>Y(e,t,[o])}function Jr(e,t,r){return O(e,r),()=>Y(e,t,[])}function Kr(e,t,r){return O(e,r),o=>me(e,t,[o])}function Zr(e,t,r){return O(e,r),(o,n)=>Y(e,t,[o,n])}function cr(e,t){if(!te(e))throw new TypeError(t+" is not a WritableStream.")}Object.defineProperties(Ce.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Ce.prototype,b.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class je{constructor(t={},r={}){void 0===t?t=null:Yt(t,"First parameter");const o=We(r,"Second parameter"),n=function(s,a){B(s,a);const u=s?.abort,l=s?.close,f=s?.start,_=s?.type,c=s?.write;return{abort:void 0===u?void 0:Xr(u,s,a+" has member 'abort' that"),close:void 0===l?void 0:Jr(l,s,a+" has member 'close' that"),start:void 0===f?void 0:Kr(f,s,a+" has member 'start' that"),write:void 0===c?void 0:Zr(c,s,a+" has member 'write' that"),type:_}}(t,"First parameter");if(fr(this),void 0!==n.type)throw new RangeError("Invalid type is specified");const i=Oe(o);!function(s,a,u,l){const f=Object.create(de.prototype);let _=()=>{},c=()=>w(void 0),y=()=>w(void 0),g=()=>w(void 0);void 0!==a.start&&(_=()=>a.start(f)),void 0!==a.write&&(c=m=>a.write(m,f)),void 0!==a.close&&(y=()=>a.close()),void 0!==a.abort&&(g=m=>a.abort(m)),gr(s,f,_,c,y,g,u,l)}(this,n,ce(o,1),i)}get locked(){if(!te(this))throw Le("locked");return re(this)}abort(t){return te(this)?re(this)?d(new TypeError("Cannot abort a stream that already has a writer")):Ae(this,t):d(Le("abort"))}close(){return te(this)?re(this)?d(new TypeError("Cannot close a stream that already has a writer")):A(this)?d(new TypeError("Cannot close an already-closing stream")):hr(this):d(Le("close"))}getWriter(){if(!te(this))throw Le("getWriter");return dr(this)}}function dr(e){return new Be(e)}function fr(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new j,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function te(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function re(e){return void 0!==e._writer}function Ae(e,t){const r=e._state;if("closed"===r||"errored"===r)return w(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let o=!1;"erroring"===r&&(o=!0,t=void 0);const n=q((i,s)=>{e._pendingAbortRequest={_promise:void 0,_resolve:i,_reject:s,_reason:t,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,o||gt(e,t),n}function hr(e){const t=e._state;if("closed"===t||"errored"===t)return d(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=q((i,s)=>{e._closeRequest={_resolve:i,_reject:s}}),o=e._writer;var n;return void 0!==o&&e._backpressure&&"writable"===t&&qt(o),ct(n=e._writableStreamController,yr,0),Ie(n),r}function yt(e,t){"writable"!==e._state?wt(e):gt(e,t)}function gt(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const o=e._writer;var n;void 0!==o&&br(o,t),void 0===(n=e)._inFlightWriteRequest&&void 0===n._inFlightCloseRequest&&r._started&&wt(e)}function wt(e){e._state="errored",e._writableStreamController[Qt]();const t=e._storedError;if(e._writeRequests.forEach(o=>{o._reject(t)}),e._writeRequests=new j,void 0===e._pendingAbortRequest)return void ze(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void ze(e);k(e._writableStreamController[Nt](r._reason),()=>{r._resolve(),ze(e)},o=>{r._reject(o),ze(e)})}function A(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function ze(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&Tt(t,e._storedError)}function vt(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?$e(r):qt(r)),e._backpressure=t}Object.defineProperties(je.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(je.prototype,b.toStringTag,{value:"WritableStream",configurable:!0});class Be{constructor(t){if(F(t,1,"WritableStreamDefaultWriter"),cr(t,"First parameter"),re(t))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;const r=t._state;if("writable"===r)!A(t)&&t._backpressure?$e(this):Tr(this),Me(this);else if("erroring"===r)Pt(this,t._storedError),Me(this);else if("closed"===r)Tr(this),Me(this),Rr(this);else{const n=t._storedError;Pt(this,n),Sr(this,n)}}get closed(){return G(this)?this._closedPromise:d(X("closed"))}get desiredSize(){if(!G(this))throw X("desiredSize");if(void 0===this._ownerWritableStream)throw fe("desiredSize");return function(t){const r=t._ownerWritableStream,o=r._state;return"errored"===o||"erroring"===o?null:"closed"===o?0:wr(r._writableStreamController)}(this)}get ready(){return G(this)?this._readyPromise:d(X("ready"))}abort(t){return G(this)?void 0===this._ownerWritableStream?d(fe("abort")):Ae(this._ownerWritableStream,t):d(X("abort"))}close(){if(!G(this))return d(X("close"));const t=this._ownerWritableStream;return void 0===t?d(fe("close")):A(t)?d(new TypeError("Cannot close an already-closing stream")):_r(this)}releaseLock(){if(!G(this))throw X("releaseLock");void 0!==this._ownerWritableStream&&pr(this)}write(t){return G(this)?void 0===this._ownerWritableStream?d(fe("write to")):mr(this,t):d(X("write"))}}function G(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function _r(e){return hr(e._ownerWritableStream)}function br(e,t){"pending"===e._readyPromiseState?Pr(e,t):Pt(e,t)}function pr(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");br(e,r),function eo(e,t){"pending"===e._closedPromiseState?Tt(e,t):Sr(e,t)}(e,r),t._writer=void 0,e._ownerWritableStream=void 0}function mr(e,t){const r=e._ownerWritableStream,o=r._writableStreamController,n=function(a,u){try{return a._strategySizeAlgorithm(u)}catch(l){return St(a,l),1}}(o,t);if(r!==e._ownerWritableStream)return d(fe("write to"));const i=r._state;if("errored"===i)return d(r._storedError);if(A(r)||"closed"===i)return d(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===i)return d(r._storedError);const s=(a=r,q((u,l)=>{a._writeRequests.push({_resolve:u,_reject:l})}));var a;return function(a,u,l){try{ct(a,u,l)}catch(_){return void St(a,_)}const f=a._controlledWritableStream;!A(f)&&"writable"===f._state&&vt(f,Rt(a)),Ie(a)}(o,t,n),s}Object.defineProperties(Be.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Be.prototype,b.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const yr={};class de{constructor(){throw new TypeError("Illegal constructor")}error(t){if(!E(this)||!Object.prototype.hasOwnProperty.call(this,"_controlledWritableStream"))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&vr(this,t)}[Nt](t){const r=this._abortAlgorithm(t);return Fe(this),r}[Qt](){I(this)}}function gr(e,t,r,o,n,i,s,a){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,I(t),t._started=!1,t._strategySizeAlgorithm=a,t._strategyHWM=s,t._writeAlgorithm=o,t._closeAlgorithm=n,t._abortAlgorithm=i;const u=Rt(t);vt(e,u),k(w(r()),()=>{t._started=!0,Ie(t)},l=>{t._started=!0,yt(e,l)})}function Fe(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function wr(e){return e._strategyHWM-e._queueTotalSize}function Ie(e){const t=e._controlledWritableStream;if(!e._started||void 0!==t._inFlightWriteRequest)return;if("erroring"===t._state)return void wt(t);if(0===e._queue.length)return;const r=e._queue.peek().value;r===yr?function(o){const n=o._controlledWritableStream;var s;(s=n)._inFlightCloseRequest=s._closeRequest,s._closeRequest=void 0,ut(o);const i=o._closeAlgorithm();Fe(o),k(i,()=>{!function(s){s._inFlightCloseRequest._resolve(void 0),s._inFlightCloseRequest=void 0,"erroring"===s._state&&(s._storedError=void 0,void 0!==s._pendingAbortRequest&&(s._pendingAbortRequest._resolve(),s._pendingAbortRequest=void 0)),s._state="closed";const a=s._writer;void 0!==a&&Rr(a)}(n)},s=>{var a,u;(a=n)._inFlightCloseRequest._reject(u=s),a._inFlightCloseRequest=void 0,void 0!==a._pendingAbortRequest&&(a._pendingAbortRequest._reject(u),a._pendingAbortRequest=void 0),yt(a,u)})}(e):function(o,n){const i=o._controlledWritableStream;var s;(s=i)._inFlightWriteRequest=s._writeRequests.shift(),k(o._writeAlgorithm(n),()=>{var a;(a=i)._inFlightWriteRequest._resolve(void 0),a._inFlightWriteRequest=void 0;const s=i._state;if(ut(o),!A(i)&&"writable"===s){const a=Rt(o);vt(i,a)}Ie(o)},s=>{var a,u;"writable"===i._state&&Fe(o),(a=i)._inFlightWriteRequest._reject(u=s),a._inFlightWriteRequest=void 0,yt(a,u)})}(e,r)}function St(e,t){"writable"===e._controlledWritableStream._state&&vr(e,t)}function Rt(e){return wr(e)<=0}function vr(e,t){const r=e._controlledWritableStream;Fe(e),gt(r,t)}function Le(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function X(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function fe(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Me(e){e._closedPromise=q((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending"})}function Sr(e,t){Me(e),Tt(e,t)}function Tt(e,t){void 0!==e._closedPromise_reject&&(ae(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function Rr(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function $e(e){e._readyPromise=q((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r}),e._readyPromiseState="pending"}function Pt(e,t){$e(e),Pr(e,t)}function Tr(e){$e(e),qt(e)}function Pr(e,t){void 0!==e._readyPromise_reject&&(ae(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function qt(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(de.prototype,{error:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(de.prototype,b.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const qr=typeof DOMException<"u"?DOMException:void 0,to=function(e){if("function"!=typeof e&&"object"!=typeof e)return!1;try{return new e,!0}catch{return!1}}(qr)?qr:function(){const e=function(t,r){this.message=t||"",this.name=r||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return Object.defineProperty(e.prototype=Object.create(Error.prototype),"constructor",{value:e,writable:!0,configurable:!0}),e}();function Er(e,t,r,o,n,i){const s=ye(e),a=dr(t);e._disturbed=!0;let u=!1,l=w(void 0);return q((f,_)=>{let c;if(void 0!==i){if(c=()=>{const p=new to("Aborted","AbortError"),R=[];o||R.push(()=>"writable"===t._state?Ae(t,p):w(void 0)),n||R.push(()=>"readable"===e._state?J(e,p):w(void 0)),v(()=>Promise.all(R.map(C=>C())),!0,p)},i.aborted)return void c();i.addEventListener("abort",c)}var g,m;if(S(e,s._closedPromise,p=>{o?D(!0,p):v(()=>Ae(t,p),!0,p)}),S(t,a._closedPromise,p=>{n?D(!0,p):v(()=>J(e,p),!0,p)}),g=s._closedPromise,m=()=>{r?D():v(()=>function(p){const R=p._ownerWritableStream,C=R._state;return A(R)||"closed"===C?w(void 0):"errored"===C?d(R._storedError):_r(p)}(a))},"closed"===e._state?m():Ze(g,m),A(t)||"closed"===t._state){const p=new TypeError("the destination writable stream closed before all data could be piped to it");n?D(!0,p):v(()=>J(e,p),!0,p)}function h(){const p=l;return z(l,()=>p!==l?h():void 0)}function S(p,R,C){"errored"===p._state?C(p._storedError):It(R,C)}function v(p,R,C){function T(){k(p(),()=>N(R,C),P=>N(!0,P))}u||(u=!0,"writable"!==t._state||A(t)?T():Ze(h(),T))}function D(p,R){u||(u=!0,"writable"!==t._state||A(t)?N(p,R):Ze(h(),()=>N(p,R)))}function N(p,R){pr(a),H(s),void 0!==i&&i.removeEventListener("abort",c),p?_(R):f(void 0)}ae(q((p,R)=>{!function C(T){T?p():z(u?w(!0):z(a._readyPromise,()=>q((P,W)=>{ve(s,{_chunkSteps:Q=>{l=z(mr(a,Q),void 0,Je),P(!1)},_closeSteps:()=>P(!0),_errorSteps:W})})),C,R)}(!1)}))})}class he{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!De(this))throw xe("desiredSize");return Et(this)}close(){if(!De(this))throw xe("close");if(!oe(this))throw new TypeError("The stream is not in a state that permits close");be(this)}enqueue(t){if(!De(this))throw xe("enqueue");if(!oe(this))throw new TypeError("The stream is not in a state that permits enqueue");return Qe(this,t)}error(t){if(!De(this))throw xe("error");L(this,t)}[ot](t){I(this);const r=this._cancelAlgorithm(t);return Ne(this),r}[nt](t){const r=this._controlledReadableStream;if(this._queue.length>0){const o=ut(this);this._closeRequested&&0===this._queue.length?(Ne(this),pe(r)):_e(this),t._chunkSteps(o)}else Ut(r,t),_e(this)}}function De(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function _e(e){if(Cr(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,k(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,_e(e))},t=>{L(e,t)})}}function Cr(e){const t=e._controlledReadableStream;return!(!oe(e)||!e._started)&&(!!($(t)&&ge(t)>0)||Et(e)>0)}function Ne(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function be(e){if(!oe(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(Ne(e),pe(t))}function Qe(e,t){if(!oe(e))return;const r=e._controlledReadableStream;if($(r)&&ge(r)>0)lt(r,t,!1);else{let o;try{o=e._strategySizeAlgorithm(t)}catch(n){throw L(e,n),n}try{ct(e,t,o)}catch(n){throw L(e,n),n}}_e(e)}function L(e,t){const r=e._controlledReadableStream;"readable"===r._state&&(I(e),Ne(e),jr(r,t))}function Et(e){const t=e._controlledReadableStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function oe(e){return!e._closeRequested&&"readable"===e._controlledReadableStream._state}function kr(e,t,r,o,n,i,s){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,I(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=s,t._strategyHWM=i,t._pullAlgorithm=o,t._cancelAlgorithm=n,e._readableStreamController=t,k(w(r()),()=>{t._started=!0,_e(t)},a=>{L(t,a)})}function xe(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function ro(e,t,r){return O(e,r),o=>Y(e,t,[o])}function oo(e,t,r){return O(e,r),o=>Y(e,t,[o])}function no(e,t,r){return O(e,r),o=>me(e,t,[o])}function io(e,t){if("bytes"!=(e=""+e))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function ao(e,t){if("byob"!=(e=""+e))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Or(e,t){B(e,t);const r=e?.preventAbort,o=e?.preventCancel,n=e?.preventClose,i=e?.signal;return void 0!==i&&function(s,a){if(!function(u){if("object"!=typeof u||null===u)return!1;try{return"boolean"==typeof u.aborted}catch{return!1}}(s))throw new TypeError(a+" is not an AbortSignal.")}(i,t+" has member 'signal' that"),{preventAbort:!!r,preventCancel:!!o,preventClose:!!n,signal:i}}Object.defineProperties(he.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(he.prototype,b.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class ne{constructor(t={},r={}){void 0===t?t=null:Yt(t,"First parameter");const o=We(r,"Second parameter"),n=function(i,s){B(i,s);const a=i,u=a?.autoAllocateChunkSize,l=a?.cancel,f=a?.pull,_=a?.start,c=a?.type;return{autoAllocateChunkSize:void 0===u?void 0:Vt(u,s+" has member 'autoAllocateChunkSize' that"),cancel:void 0===l?void 0:ro(l,a,s+" has member 'cancel' that"),pull:void 0===f?void 0:oo(f,a,s+" has member 'pull' that"),start:void 0===_?void 0:no(_,a,s+" has member 'start' that"),type:void 0===c?void 0:io(c,s+" has member 'type' that")}}(t,"First parameter");if(Wr(this),"bytes"===n.type){if(void 0!==o.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function Ur(e,t,r){const o=Object.create(Pe.prototype);let n=()=>{},i=()=>w(void 0),s=()=>w(void 0);void 0!==t.start&&(n=()=>t.start(o)),void 0!==t.pull&&(i=()=>t.pull(o)),void 0!==t.cancel&&(s=u=>t.cancel(u));const a=t.autoAllocateChunkSize;if(0===a)throw new TypeError("autoAllocateChunkSize must be greater than 0");var u,l,f,_,c,y,g;f=n,_=i,c=s,y=r,g=a,(l=o)._controlledReadableByteStream=u=e,l._pullAgain=!1,l._pulling=!1,l._byobRequest=null,l._queue=l._queueTotalSize=void 0,I(l),l._closeRequested=!1,l._started=!1,l._strategyHWM=y,l._pullAlgorithm=_,l._cancelAlgorithm=c,l._autoAllocateChunkSize=g,l._pendingPullIntos=new j,u._readableStreamController=l,k(w(f()),()=>{l._started=!0,U(l)},m=>{se(l,m)})}(this,n,ce(o,0))}else{const i=Oe(o);!function(s,a,u,l){const f=Object.create(he.prototype);let _=()=>{},c=()=>w(void 0),y=()=>w(void 0);void 0!==a.start&&(_=()=>a.start(f)),void 0!==a.pull&&(c=()=>a.pull(f)),void 0!==a.cancel&&(y=g=>a.cancel(g)),kr(s,f,_,c,y,u,l)}(this,n,ce(o,1),i)}}get locked(){if(!M(this))throw K("locked");return $(this)}cancel(t){return M(this)?$(this)?d(new TypeError("Cannot cancel a stream that already has a reader")):J(this,t):d(K("cancel"))}getReader(t){if(!M(this))throw K("getReader");return void 0===function(r,o){B(r,o);const n=r?.mode;return{mode:void 0===n?void 0:ao(n,o+" has member 'mode' that")}}(t,"First parameter").mode?ye(this):new Ce(this)}pipeThrough(t,r={}){if(!M(this))throw K("pipeThrough");F(t,1,"pipeThrough");const o=function(i,s){B(i,s);const a=i?.readable;it(a,"readable","ReadableWritablePair"),st(a,s+" has member 'readable' that");const u=i?.writable;return it(u,"writable","ReadableWritablePair"),cr(u,s+" has member 'writable' that"),{readable:a,writable:u}}(t,"First parameter"),n=Or(r,"Second parameter");if($(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(re(o.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return ae(Er(this,o.writable,n.preventClose,n.preventAbort,n.preventCancel,n.signal)),o.readable}pipeTo(t,r={}){if(!M(this))return d(K("pipeTo"));if(void 0===t)return d("Parameter 1 is required in 'pipeTo'.");if(!te(t))return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let o;try{o=Or(r,"Second parameter")}catch(n){return d(n)}return $(this)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):re(t)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Er(this,t,o.preventClose,o.preventAbort,o.preventCancel,o.signal)}tee(){if(!M(this))throw K("tee");const t=function(r,o){const n=ye(r);let i,s,a,u,l,f=!1,_=!1,c=!1;const y=q(h=>{l=h});function g(){return f||(f=!0,ve(n,{_chunkSteps:h=>{Lt(()=>{f=!1;const v=h;_||Qe(a._readableStreamController,h),c||Qe(u._readableStreamController,v)})},_closeSteps:()=>{f=!1,_||be(a._readableStreamController),c||be(u._readableStreamController),_&&c||l(void 0)},_errorSteps:()=>{f=!1}})),w(void 0)}function m(){}return a=Ct(m,g,function(h){if(_=!0,i=h,c){const S=dt([i,s]),v=J(r,S);l(v)}return y}),u=Ct(m,g,function(h){if(c=!0,s=h,_){const S=dt([i,s]),v=J(r,S);l(v)}return y}),It(n._closedPromise,h=>{L(a._readableStreamController,h),L(u._readableStreamController,h),_&&c||l(void 0)}),[a,u]}(this);return dt(t)}values(t){if(!M(this))throw K("values");return function(r,o){const n=ye(r),i=new Vr(n,o),s=Object.create(Xt);return s._asyncIteratorImpl=i,s}(this,(r=t,B(r,"First parameter"),{preventCancel:!!r?.preventCancel}).preventCancel);var r}}function Ct(e,t,r,o=1,n=(()=>1)){const i=Object.create(ne.prototype);return Wr(i),kr(i,Object.create(he.prototype),e,t,r,o,n),i}function Wr(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function M(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function $(e){return void 0!==e._reader}function J(e,t){return e._disturbed=!0,"closed"===e._state?w(void 0):"errored"===e._state?d(e._storedError):(pe(e),x(e._readableStreamController[ot](t),Je))}function pe(e){e._state="closed";const t=e._reader;void 0!==t&&(Dt(t),V(t)&&(t._readRequests.forEach(r=>{r._closeSteps()}),t._readRequests=new j))}function jr(e,t){e._state="errored",e._storedError=t;const r=e._reader;void 0!==r&&(rt(r,t),V(r)?(r._readRequests.forEach(o=>{o._errorSteps(t)}),r._readRequests=new j):(r._readIntoRequests.forEach(o=>{o._errorSteps(t)}),r._readIntoRequests=new j))}function K(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Ar(e,t){B(e,t);const r=e?.highWaterMark;return it(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:at(r)}}Object.defineProperties(ne.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(ne.prototype,b.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof b.asyncIterator&&Object.defineProperty(ne.prototype,b.asyncIterator,{value:ne.prototype.values,writable:!0,configurable:!0});const so=function(e){return e.byteLength};class kt{constructor(t){F(t,1,"ByteLengthQueuingStrategy"),t=Ar(t,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!Br(this))throw zr("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!Br(this))throw zr("size");return so}}function zr(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function Br(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")}Object.defineProperties(kt.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(kt.prototype,b.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const lo=function(){return 1};class Ot{constructor(t){F(t,1,"CountQueuingStrategy"),t=Ar(t,"First parameter"),this._countQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!Ir(this))throw Fr("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!Ir(this))throw Fr("size");return lo}}function Fr(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function Ir(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")}function uo(e,t,r){return O(e,r),o=>Y(e,t,[o])}function co(e,t,r){return O(e,r),o=>me(e,t,[o])}function fo(e,t,r){return O(e,r),(o,n)=>Y(e,t,[o,n])}Object.defineProperties(Ot.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Ot.prototype,b.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class Wt{constructor(t={},r={},o={}){void 0===t&&(t=null);const n=We(r,"Second parameter"),i=We(o,"Third parameter"),s=function(c,y){B(c,y);const g=c?.flush,m=c?.readableType,h=c?.start,S=c?.transform,v=c?.writableType;return{flush:void 0===g?void 0:uo(g,c,y+" has member 'flush' that"),readableType:m,start:void 0===h?void 0:co(h,c,y+" has member 'start' that"),transform:void 0===S?void 0:fo(S,c,y+" has member 'transform' that"),writableType:v}}(t,"First parameter");if(void 0!==s.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==s.writableType)throw new RangeError("Invalid writableType specified");const a=ce(i,0),u=Oe(i),l=ce(n,1),f=Oe(n);let _;(function(c,y,g,m,h,S){function v(){return y}c._writable=function(T,P,W,Q,ie=1,ho=(()=>1)){const jt=Object.create(je.prototype);return fr(jt),gr(jt,Object.create(de.prototype),T,P,W,Q,ie,ho),jt}(v,function D(T){return function(P,W){const Q=P._transformStreamController;return P._backpressure?x(P._backpressureChangePromise,()=>{const ie=P._writable;if("erroring"===ie._state)throw ie._storedError;return Dr(Q,W)}):Dr(Q,W)}(c,T)},function p(){return function(T){const P=T._readable,W=T._transformStreamController,Q=W._flushAlgorithm();return Mr(W),x(Q,()=>{if("errored"===P._state)throw P._storedError;be(P._readableStreamController)},ie=>{throw Ye(T,ie),P._storedError})}(c)},function N(T){return Ye(c,T),w(void 0)},g,m),c._readable=Ct(v,function R(){return Ve(T=c,!1),T._backpressureChangePromise;var T},function C(T){return He(c,T),w(void 0)},h,S),c._backpressure=void 0,c._backpressureChangePromise=void 0,c._backpressureChangePromise_resolve=void 0,Ve(c,!0),c._transformStreamController=void 0})(this,q(c=>{_=c}),l,f,a,u),function(c,y){const g=Object.create(Ue.prototype);let m=S=>{try{return $r(g,S),w(void 0)}catch(v){return d(v)}},h=()=>w(void 0);var S,v,D,N;void 0!==y.transform&&(m=S=>y.transform(S,g)),void 0!==y.flush&&(h=()=>y.flush(g)),D=m,N=h,(v=g)._controlledTransformStream=S=c,S._transformStreamController=v,v._transformAlgorithm=D,v._flushAlgorithm=N}(this,s),_(void 0!==s.start?s.start(this._transformStreamController):void 0)}get readable(){if(!Lr(this))throw Nr("readable");return this._readable}get writable(){if(!Lr(this))throw Nr("writable");return this._writable}}function Lr(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function Ye(e,t){L(e._readable._readableStreamController,t),He(e,t)}function He(e,t){Mr(e._transformStreamController),St(e._writable._writableStreamController,t),e._backpressure&&Ve(e,!1)}function Ve(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=q(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=t}Object.defineProperties(Wt.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Wt.prototype,b.toStringTag,{value:"TransformStream",configurable:!0});class Ue{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Ge(this))throw Xe("desiredSize");return Et(this._controlledTransformStream._readable._readableStreamController)}enqueue(t){if(!Ge(this))throw Xe("enqueue");$r(this,t)}error(t){if(!Ge(this))throw Xe("error");Ye(this._controlledTransformStream,t)}terminate(){if(!Ge(this))throw Xe("terminate");!function(t){const r=t._controlledTransformStream;be(r._readable._readableStreamController),He(r,new TypeError("TransformStream terminated"))}(this)}}function Ge(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function Mr(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function $r(e,t){const r=e._controlledTransformStream,o=r._readable._readableStreamController;if(!oe(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{Qe(o,t)}catch(n){throw He(r,n),r._readable._storedError}var n;!Cr(n=o)!==r._backpressure&&Ve(r,!0)}function Dr(e,t){return x(e._transformAlgorithm(t),void 0,r=>{throw Ye(e._controlledTransformStream,r),r})}function Xe(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Nr(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(Ue.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof b.toStringTag&&Object.defineProperty(Ue.prototype,b.toStringTag,{value:"TransformStreamDefaultController",configurable:!0})}}]);